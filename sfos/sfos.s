; vim: ft=asm_ca65 ts=4 sw=4 et
.include "fcb.inc"
.autoimport

.globalzp ptr1

.zeropage

cmd:        .word 0
param:      .word 0
user_dma:   .word 0

.code

; reset with warm boot and log into drive A
sfos_s_reset:
    jsr bios_wboot
    lda #1
    sta current_drive
    rts

; read a char from the serial console
; echo it too
sfos_c_read:
    jsr bios_conin          ; read from serial terminal
    pha                     ; stash it
    jsr internal_c_write    ; echo it to the terminal
    pla                     ; pop it
    rts

; send a char to the serial console and check for CTRL + C
sfos_c_write:
    lda param + 0
internal_c_write:
    jsr bios_conout
    jsr bios_const
    beq @exit
    cmp #$03                ; we do a quick ^C check here and perform a soft
    bne @exit               ; boot if we find one.
    jmp sfos_s_reset
@exit:
    rts

; print a null terminated string pointed to by XA to the serial console.
sfos_c_printstr:
@L1:
    lda (param)
    beq @exit               ; we use null termination 'round 'ere
    jsr internal_c_write
    inc param + 0
    bne @L1
    inc param + 1
    bra @L1
@exit:
    rts

; reads a line of text from the serial console into the commandline buffer
sfos_c_readstr:
    lda (param)
    cmp #$80
    bcc :+                  ; max commandline length is 128
    lda #$80
:   sta cmdlen
    ldy #1
@L1:
    jsr bios_conin
    cmp #3
    beq @done
    cmp #10
    beq @enter
    cmp #13
    beq @enter
    cmp #$08
    beq @backspace
    sta (param),y
    jsr bios_conout
    iny
    cpy cmdlen
    bne @L1
@done:
    tya
    sta (param)             ; overwrite the commandline length with the
    rts                     ; actual commandline length entered.
@enter:
    lda #0
    sta (param),y
    bra @done
@backspace:
    cpy #1
    beq @L1
    dey
    jsr bios_conout
    lda #' '
    jsr bios_conout
    lda #$08
    jsr bios_conout
    bra @L1

sfos_c_status:
    jmp unimplimented

; Gets or sets the current drive.  When the current drive changes, we set LBA
sfos_d_getsetdrive:
    lda param + 0
    cmp #$FF
    bne @L1
    lda current_drive       ; return the current_drive
    bra @exit
@L1:
    jsr bios_conout
    cmp current_drive
    beq @exit
    ; drive is different
    cmp #7
    bcs @out_of_range
    sta current_drive
    sta lba + 3             ; drive number is the 3rd byte of the LBA
    stz lba + 0             ; all other bytes of the LBA are reset to 0
    stz lba + 1             ; as we have changed to another drive.
    stz lba + 4
    jsr bios_setlba
@exit:
    clc
    rts
@out_of_range:
    sec
    rts

sfos_d_createfcb:
    jmp unimplimented

; the user_dma pointer points to the buffer containing the commandline
; param points to the FCB Read in the commandline and fill out the FCB
; BORROWED FROM CPM65 By David Given (https://github.com/davidgiven/cpm65)
sfos_d_parsefcb:
    ; param -> commandline (filename)
    ; dma -> FCB
    lda #0
    sta temp+1              ; failure flag

    ; check the drive

    ldy #0
    ldx #0
    lda (param),y           ; drive letter?
    beq @nodrive
    iny
    lda (param),y
    dey
    cmp #':'                ; colon?
    bne @nodrive
    lda (param),y
    jsr to_upper
    sec
    sbc #'A'-1              ; to 1 based drive
    cmp #8                  ; we only support 8 drives on sfs
    bcc :+                  ; carry is clear if drive is less than 8 (0-7)
    dec temp+1
:
    tax
    iny
    iny
@nodrive:
    txa
    pha                     ; drive letter pushed to stack

    ; Read the filename

    ldx #8
@L1:
    lda (param),y           ; get a character
    jsr to_upper
    jsr is_terminator_char
    bcc :+                  ; if carry set
    lda #' '
    dey
:   cmp #'*'
    bne :+                  ; if a star
    lda #'?'
    dey
:   pha
    iny
    dex
    bne @L1

    ; skip non-dot fiename characters.
    lda (param),y
@L2:
    cmp #'.'
    beq :++
    jsr is_terminator_char
    bcc :+                  ; if carry set do the below.
    lda #' '                ; filename has no extension
    pha
    pha
    pha
    bra @parse_filename_exit
:   iny
    lda (param),y
    bra @L2
    ; read the extension

:   iny
    ldx #3
@L3:
    lda (param),y           ; get a character
    jsr to_upper
    jsr is_terminator_char
    bcc :+                  ; if carry set do the below
    lda #' '
    dey
:   cmp #'*'
    bne :+
    lda #'?'
    dey
:   pha
    iny
    dex
    bne @L3

    ; discard remaining filename characters
    lda (param),y
@L4:
    jsr is_terminator_char
    bcs @parse_filename_exit
    iny
    lda (param),y
    bne @L4

@parse_filename_exit:
    ; push the 4 zeros for L1, L2, SC, FN
    lda #0
    pha
    pha
    pha
    pha

    ; copy the generated bytes from the stack into the destination

    tya
    tax
    ldy #15
@L5:
    pla
    sta (user_dma),y
    dey
    bpl @L5
    txa
    clc
    adc param+0
    ldx param+1
    bcc :+                  ; did we rollover on the adc above?
    inx
:   clc
    ldy temp+1              ; was there a failure?
    beq :+
    sec
:   rts

sfos_d_find:
    jmp unimplimented

sfos_d_make:
    jmp unimplimented

sfos_d_open:
    jmp unimplimented

sfos_d_close:
    jmp unimplimented

sfos_d_setdma:
    lda param + 0
    sta user_dma + 0
    ldx param + 1
    stx user_dma + 1
    jmp bios_setdma

sfos_d_readseqblock:
    jmp unimplimented

sfos_d_writeseqblock:
    jmp unimplimented

sfos_d_readseqbyte:
    jmp unimplimented

sfos_d_writeseqbyte:
    jmp unimplimented

;---- HELPER FUNCTIONS -------------------------------------------------------
unimplimented:
    lda #<str_unimplimented
    lda #>str_unimplimented
    jmp bios_puts

; converts a characater to upper case
to_upper:
    cmp #'a'
    bcc @done
    cmp #'z' + 1
    bcs @done
    and #$DF
@done:
    rts

is_terminator_char:
    stx temp+2
    ldx #(terminators_end - terminators) - 1
:   cmp terminators, x          ; sets carry if equal
    beq :+
    dex
    bpl :-
    clc
:   ldx temp+2
    rts

.bss
    current_drive:  .byte 0
    lba:            .res 4,0
    cmdlen:         .byte 0
    temp:           .res 4

.segment "SYSTEM"
; dispatch function, will be relocated on boot into SYSRAM
dispatch:
    sta param + 0
    stx param + 1
    lda sfos_jmp_tbl_hi,y
    sta cmd + 1
    lda sfos_jmp_tbl_lo,y
    sta cmd + 0
    jmp (cmd)

.rodata

sfos_jmp_tbl_lo:
    .lobytes sfos_s_reset
    .lobytes sfos_c_read
    .lobytes sfos_c_write
    .lobytes sfos_c_printstr
    .lobytes sfos_c_readstr
    .lobytes sfos_c_status
    .lobytes sfos_d_getsetdrive
    .lobytes sfos_d_createfcb
    .lobytes sfos_d_parsefcb
    .lobytes sfos_d_find
    .lobytes sfos_d_make
    .lobytes sfos_d_open
    .lobytes sfos_d_close
    .lobytes sfos_d_setdma
    .lobytes sfos_d_readseqblock
    .lobytes sfos_d_writeseqblock
    .lobytes sfos_d_readseqbyte
    .lobytes sfos_d_writeseqbyte
sfos_jmp_tbl_hi:
    .hibytes sfos_s_reset
    .hibytes sfos_c_read
    .hibytes sfos_c_write
    .hibytes sfos_c_printstr
    .hibytes sfos_c_readstr
    .hibytes sfos_c_status
    .hibytes sfos_d_getsetdrive
    .hibytes sfos_d_createfcb
    .hibytes sfos_d_parsefcb
    .hibytes sfos_d_find
    .hibytes sfos_d_make
    .hibytes sfos_d_open
    .hibytes sfos_d_close
    .hibytes sfos_d_setdma
    .hibytes sfos_d_readseqblock
    .hibytes sfos_d_writeseqblock
    .hibytes sfos_d_readseqbyte
    .hibytes sfos_d_writeseqbyte

banner:             .byte "6502-Retro! (SFOS)", 13, 10, 0
str_unimplimented:  .byte 13, 10, "!!! UNIMPLIMENTED !!!", 13, 10, 0 
str_badfilename:    .byte 13, 10, "BAD FILENAME", 13,10,0
str_COM: .byte "COM"
terminators:
    .byte " =><.:,[]/|"
    .byte 10,13,127,9,0
terminators_end:
